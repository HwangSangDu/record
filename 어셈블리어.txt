

익스플로잇 = 악용하다 , 착취하다. 
보안업계에서는 취약점을 찾아서 악용하는 것을 말한다.

프로그램 분석해서 취약점을 찾을 수 있어야 한다.

* 프로그래밍을 할 줄 알아야 한다. = 우리들의 몫
파이썬은 세계에서 가장 많이 사용하는 언어이다.(장점)

* 역공학을 통한 취약점 해결방법

* 소프트웨어가 수정하기가 더 쉽다.
소프트웨어를 해킹하는 것이 더 쉽다.

* 하드웨어는 비용이 더 많이 든다.

최종 산물은 기계어이다.
기계어는 컴퓨터가 이해하는 언어
어셈블리어는 사람이 이해하는 언어

기계어와 어셈블리어는 1대1로 (맵핑)사상한다.
역공학이 가능하다는 것은 서로 변환이 가능하다는 것이다.
 
 어셈블리언어는 꼭 해야 한다.
 

* 어셈블리어 뽑아내는 s방법

objdump는 전체적으로 다 볼 수 있다.

gdb는 보고 싶은 것을 볼 수 있다.

하나의 툴만으로는 노답이다.
IDA나 다른 도구를 모두 활용하는 것이 좋다.



** objdump -d ./test
 
 
 printt exist :

  40052d:	55                   	push   %rbp
  40052e:	48 89 e5             	mov    %rsp,%rbp

  400531:	bf d4 05 40 00       	mov    $0x4005d4,%edi
  400536:	e8 d5 fe ff ff       	callq  400410 <puts@plt>
  //위 2줄은 뺴고는  디폴트로 들어가는 어셈블리어 소스이다.
  40053b:	b8 00 00 00 00       	mov    $0x0,%eax
  400540:	5d                   	pop    %rbp
  400541:	c3                   	retq   


printf don't exist :

   0x00000000004004ed <+0>:	push   %rbp
   0x00000000004004ee <+1>:	mov    %rsp,%rbp
   0x00000000004004f1 <+4>:	mov    $0x0,%eax
   0x00000000004004f6 <+9>:	pop    %rbp
   0x00000000004004f7 <+10>:	retq   


printf를 2번 사용했을 떄 :

   Dump of assembler code for function main:
   0x000000000040052d <+0>:	push   %rbp
   0x000000000040052e <+1>:	mov    %rsp,%rbp
   
   0x0000000000400531 <+4>:	mov    $0x4005e4,%edi
   0x0000000000400536 <+9>:	mov    $0x0,%eax
   0x000000000040053b <+14>:	callq  0x400410 <printf@plt>
   0x0000000000400540 <+19>:	mov    $0x4005e4,%edi
   0x0000000000400545 <+24>:	mov    $0x0,%eax
   0x000000000040054a <+29>:	callq  0x400410 <printf@plt>
	// 조금씩 수정하면서 어셈블리어를 공부하면 좋다.
	// 많이 많이 수정해보자!
	// 코드를 짜고 어셈블리어를 예상해보자! 잘 맞출수록 역공학을 잘하는 것이다.
   0x000000000040054f <+34>:	mov    $0x0,%eax
   0x0000000000400554 <+39>:	pop    %rbp
   0x0000000000400555 <+40>:	retq   
 

 인텔 문법 & 바로 위 문법과 비교해보자!
 
   Dump of assembler code for function main:
   0x000000000040052d <+0>:	push   rbp
   0x000000000040052e <+1>:	mov    rbp,rsp
   0x0000000000400531 <+4>:	mov    edi,0x4005e4
   0x0000000000400536 <+9>:	mov    eax,0x0
   0x000000000040053b <+14>:	call   0x400410 <printf@plt>
   0x0000000000400540 <+19>:	mov    edi,0x4005e4
   0x0000000000400545 <+24>:	mov    eax,0x0
   0x000000000040054a <+29>:	call   0x400410 <printf@plt>
   0x000000000040054f <+34>:	mov    eax,0x0
   0x0000000000400554 <+39>:	pop    rbp
   0x0000000000400555 <+40>:	ret    
 
 
 
 
 물어보지 말고 직접 컴파일해서 비교하는 습관을 들이자!
 
 
 보통의 사람은 문제를 풀 때 추상화시키고 넓게 본다.
 그러나 어셈블리어는 변수명이나 이런 것들이 직관적이지 못하다.
 
 esi,edi,eax,ebx,ecx,edx - 범용레지스터
 ebp,esp,eip - 특수목적레지스터
 범용레지스터와 특수목적 레지스터의 차이 = 내가 맘대로 할 수 있는가 없는가?
 
 상대주소와 절대주소가 존재한다.
 ebp를 기준으로 접근  = 상대주소
 
 push할 떄 esp가 증가한다.
 call은 eip값을 변경한다.
 call은 jmp와 달리 반환주소를 푸쉬하고 간다.
 ebp는 함수가 바뀔 때 이외에는 변하지 않는다.
 
 
 
 1. prologue , Epilogue  없앤다.
 2. 변수 이름 설정
	2.1 지역변수 : [ebp - ??]
	2.2 전역변수 : [절대주소]
	2.3 인자 : [ebp + ??]

 3. 함수 호출 구문 추출
	3.1 push ~~ call문(반드시) --> 같은 덩어리로 보면 된다.
	3.2 [esp + ??] ~~ call문 --> 같은 덩어리로 보면 된다.
		=> 콜문 기준으로 함수 호출
	함수 호출 이후에
	첫번째 인자는 항상 ebp + 0x08
	ebp + 0x04는 반환주소가 저장되어 있다.
 4. 함수가 끝나고 eax 남은 값 => 리턴값
 5. lea 레지스터1 [~] == mov 레지스터1 ~
				=> []만 없애주면 된다.
 6. 
 
 역공학 머신러닝 개발
 
 
 
 return printf~가 올바르다.
 eax는 return 값에 해당한다.
 몇번째 인자인지 , 지역변수는 v , 인자는 a, 
 
 
 * IDA
 금방 배울 수 있으니 물어볼 것!
 내가 열고자 하는 파일의 바이너리가 32비트인가 64비트인지가 중요하다.
 
 원하는 곳에 커서를 둔다.
 밑에서 파이썬을 활용할 수 있다.
 IDApython 사용법
 
 
 
 
 
 form idaapi import *
 print "%x" % here()
 혹은
 addr = here()
 start = SegStart(addr)
 end = SegEnd(addr)
 
 for h in Functions( start , end ) :
	print "%x" % h
 
 
 이런식으로 스크립트를 작성하고 공격한다.
 
 자동으로 바꿔주는 툴 헥사레이가 잘못하는 경우가 존재한다. 
 그 경우 짚어낼 수 있도록 하기 위한 과제이다
 항상 수업이 있는 전날까지 제출한다.
 
 * 과제
 제출 주소 : xchgeaxesp@gmail.com
 1. [E01][취약점][황상두,,]
	1.1 보고서 (64비트용 규칙)
	1.2 소스코드
	1.3 실행결과 스샷
 
 * 다음시간에 배우는 것!
 - 커맨드 인젝션 취약점을
 
 
 
 
 
 
 
 
 
 
 
 
   * main 함수
  
   0x0000000000400531 <+4>:	sub    rsp,0x10
   0x0000000000400535 <+8>:	mov    DWORD PTR [rbp-0x4],edi
   0x0000000000400538 <+11>:	cmp    DWORD PTR [rbp-0x4],0x0
   0x000000000040053c <+15>:	jne    0x400543 <sum+22>
   0x000000000040053e <+17>:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000400541 <+20>:	jmp    0x400555 <sum+40>
   0x0000000000400543 <+22>:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000400546 <+25>:	sub    eax,0x1
   0x0000000000400549 <+28>:	mov    edi,eax
   0x000000000040054b <+30>:	call   0x40052d <sum>
   0x0000000000400550 <+35>:	mov    edx,DWORD PTR [rbp-0x4]
   0x0000000000400553 <+38>:	add    eax,edx
   
   
	
	
	
   * sum함수
   
   0x000000000040052d <+0>:	push   rbp
   0x000000000040052e <+1>:	mov    rbp,rsp
   0x0000000000400531 <+4>:	sub    rsp,0x10
   0x0000000000400535 <+8>:	mov    DWORD PTR [rbp-0x4],edi
   0x0000000000400538 <+11>:	cmp    DWORD PTR [rbp-0x4],0x0
   0x000000000040053c <+15>:	jne    0x400543 <sum+22>
   0x000000000040053e <+17>:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000400541 <+20>:	jmp    0x400555 <sum+40>
   0x0000000000400543 <+22>:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000400546 <+25>:	sub    eax,0x1
   0x0000000000400549 <+28>:	mov    edi,eax
   0x000000000040054b <+30>:	call   0x40052d <sum>
   0x0000000000400550 <+35>:	mov    edx,DWORD PTR [rbp-0x4]
   0x0000000000400553 <+38>:	add    eax,edx
 
 
 
 
 
 
 
 
 
 
 